# 习题一

编写一个函数：

```cpp
string replaceA11(string str, char c1, char c2);
```

它返回一个str的复制字符串，其中str中每一个c1都用c2代替。例如，调用replaceA11("nannies", 'n', 'd');

应该返回“daddies”。

```cpp
#include <cassert>
#include <cstddef>
#include <string>
#include <iostream>
using namespace std;

string replaceAll(const string &str, char c1, char c2) {
    string result = str;
    size_t found = 0;

    while (true) {
        found = result.find(c1, found);
        if (found == string::npos) break;
        result.at(found) = c2;
    }
    return result;
}

int main(){ 
    assert(replaceAll("nannies", 'n',  'd') == "daddies");
    cout << "test success!" << endl;
    return 0;
}
```

一旦你编写和测试完这个函数，编写一个重载的函数版本：

```cpp
string replaceA11(string str, string s1, string s2); 
```

该函数将str中每一个s1字符串都用s2字符串代替。

```cpp
#include <cassert>
#include <cstddef>
#include <string>
#include <iostream>
using namespace std;

string replaceAll(const string &str, char c1, char c2) {
    string result = str;
    size_t found = 0;

    while (true) {
        found = result.find(c1, found);
        if (found == string::npos) break;
        result.at(found) = c2;
    }
// 针对字符的特殊处理方式，仅适用于字符，而上述的方式可通用字符串与字符。
// 由于c++的问题，处理字符的情景时需要 replaceAll(str, (string)c1, (string)c2)
//	for (auto &ch: result) {
//        if (ch == c1) {
//            ch = c2;
//        }
//    }
    return result;
}

//实现思路：
// 使用str.find() 查找可能的 pos， 之后利用replace进行替换。
string replaceAll(const string &str, const string &s1, const string &s2) {
    string result = str;
    size_t found = 0;

    while (true) {
        found = result.find(s1, found);
        if (found == string::npos) break;
        result.replace(found, s1.length(), s2); // 注意是将s1替换成s2，因此使用的是s1的长度
    }
    return result;
}

int main(){ 
    assert(replaceAll("nannies", "na",  "d") == "dnnies");
    cout << "test success!" << endl;
    return 0;
}
```

> 使用了replace与find的API，记住find的形式。

# 习题二

通过忽略标点符号和字母大小写的差异，回文的概念通常被扩展到整个句子。例如以下句子：Madam,I'm Adam.

这是一个回文的句子，因为如果你只看字母并忽略大小写字母的区别，顺序读和倒序读是一样的。

编写一个判断函数`isSentencePalindrome(str)`，如果字符串str和回文句子的定义相匹配，则该函数返回true。你应该能够用该函数去编写一个主程序并产生以下的输出结果：

![image-20240208211553491](http://zcwave.oss-cn-qingdao.aliyuncs.com/image/image-20240208211553491.png)

```cpp
#include <cctype>
#include <string>
#include <iostream>
using namespace std;

bool isPalindrome(const string &rhs) {
    // 简洁实现：
    // return rhs == rhs.reserve();
    size_t len = rhs.length();
    if (len < 2) {
        return true;
    } else {
        char start = rhs[0];
        char finish = rhs[len - 1];
        return  start == finish && 
                isPalindrome(rhs.substr(1, len - 2));
    }
}

string normalizeSentence(const string &rhs) {
    //牢记这种对单个字符处理，并且生成新字符串的方式。
    string result;
    for (auto ch : rhs) {
        if (isalpha(ch)) {
            result += tolower(ch);
        }
    }
    return result;
}

// 实现思路:
// 将普通的句子进行normailize: "Madam, I'm Adam" ==> "madamimadam"
// 之后将规格化的句子进行回文判断。
bool isSentencePalindrome(const string &rhs) {
    return isPalindrome(normalizeSentence(rhs));
}

int main() {
    cout << "This program tests for sentence palindrome." << endl
         << "Indicate the end of the input with a blank line."<< endl;

    while (true) {
        cout << "Enter a sentence :" << endl;
        string line;
        getline(cin, line); // 使用getline读取一整行
        if (line.empty()) break;

        if (isSentencePalindrome(line)) {
            cout << "That sentence is a palindrome." << endl;
        } else {
            cout << "That sentence is not a palindrome." << endl;
        }
    }
    return 0;
}
```

# 习题三-五

## 习题三

如果你在童年玩过密码，很有可能在某些地方用过循环码（cyclic cipher），它又经常被称为凯撒密码（Caesar cipher），因为罗马历史学家苏维托尼乌斯记录到盖乌斯·尤利乌斯·凯撒使用过这项技术，运用这项技术你可以将原始消息中的每个字母用字母表中出现在它前面一个固定距离的字母来代替。

作为一个例子，假设你想通过将每个字母向前移动三个位置来编码一个消息。运用这个密码技术，每个A变为D，B变为E，以此类推。如果你到达了字母表的末尾，处理周期又回到开头，所以X变成A，Y变成B，Z变成C。为了实现一个凯撒密码，**你首先应该定义以下函数：`string encodeCaesarCipher(string str,int shift);`该函数返回一个新的字符串，它是将str中的每个字母转换成与它相隔shift处的字母形成的,如果有必要，循环回到字母表的开头。**在你实现了encodeCaesarCipher函数后，编写程序产生以下示例的运行结果：

![image-20240208220732724](http://zcwave.oss-cn-qingdao.aliyuncs.com/image/image-20240208220732724.png)

注意到翻译只适用于字母，其他任何字符都不经修改输出。此外，字母大小写不产生影响：即大小写字母按原样输出。你也应该这样编写你的程序，一个负的shift值意味着字母向着字母表开头的方向进行移动，而不是向结尾方向，正如以下示例的运行结果所表明的：

![image-20240208220743514](http://zcwave.oss-cn-qingdao.aliyuncs.com/image/image-20240208220743514.png)

```cpp
#include <cctype>
#include <string>
#include <iostream>
#include <cassert>
using namespace std;

// 核心代码在于加密部分
// ch = 'a' + (ch - 'a' + shift + 26) % 26; 
// 实际逻辑是 ch = start_pos + true_offset; 
// 1. 使用 %26 保证结果总在A~Z之间取值
// 2. 计算 true_offset 采用 +26 ，是通过补码的原则来获取，将减法转变成对应的加法。同时不影响shift为正的情景。使其满足，一个负的shift值意味着字母向着字母表开头的方向进行移动，而不是向结尾方向。
string caesarCipher(const string &rhs, int shift) {
    string result = rhs;
    for (auto &ch : result) {
        if (isalpha(ch)) {
            if (isupper(ch)) {
                ch = 'A' + (ch - 'A' + shift + 26) % 26; // encoding
            } else {
                assert(islower(ch));
                ch = 'a' + (ch - 'a' + shift + 26) % 26; // encoding
            }
        }
    }
    return result;
}

int main() {
    cout << "This program encodes a message using a Caesar cipher." << endl
         << "Enter the number of character positions ot shift: ";
    int shift;
    cin >> shift;
    cin.ignore();
    string line;
    cout << "Enter a message: ";
    getline(cin, line);
    cout << "Encoded message: " << caesarCipher(line, shift);
    return 0;
}
```

## 习题四

尽管它们确实很简单，凯撒密码也极容易被破解。毕竟，只有25个字符可移动。如果你想破解一个凯撒密码，你只需尝试所有25种可能，然后观察哪一种翻译能将原始的消息转换成可读的。一个更好的策略是原始消息中的每个字母都被任意字母代替而不是被原始消息中相隔固定距离的字符代替。这样的话，编码运算的关键是一个翻译表，它展示了26个字母中每一个改变后的加密形式。这样的一个编码策略称作字母替换密码（letter-substitution cipher）。

字母替换密码的关键是一个由26个字符构成的字符串，该字符串依次指出了字母表中每个字符的翻译。例如，关键字“QWERTYUIOPASDFGHJKLZXCVBNM”表示编码过程应该使用下面的翻译规则：

![image-20240209042124823](http://zcwave.oss-cn-qingdao.aliyuncs.com/image/image-20240209042124823.png)

> **非常简单，核心与习题2的normalization程序类似，都是对单个字符进行逐一处理。**

```cpp
#include <cassert>
#include <cctype>
#include <string>
#include <iostream>
using namespace std;

// 计算offset，并且在cipher_table中找到并替换。
string letterSubstitionCipher(  const string& message, 
                                const string &cipher_table) {
    string result;
    for (auto ch : message) {
        if (isalpha(ch)) {
            int offset = ch - 'A';
            assert(offset > 0); // 防御！
            result += cipher_table[offset];
        } else {
            result += ch;
        }
    }
    return result;
}

int main() {

    cout << "Letter substitution cipher." << endl;
    string ct, msg;
    cout << "Enter a 26-letter key: ";
    getline(cin, ct);
    assert(ct.length() == 26); // 健壮性？
    
    cout << "Enter a message: ";
    getline(cin, msg);
    cout << "Encoded message: " << letterSubstitionCipher(msg, ct);
    return 0;
}
```

## 习题五

![image-20240209043905969](http://zcwave.oss-cn-qingdao.aliyuncs.com/image/image-20240209043905969.png)

> 人生第一次触发这个。 两个回答都正确，**即避免线性搜索，将O(n^2) 变成 O(1).**

```cpp
#include <cassert>
#include <cctype>
#include <cstddef>
#include <string>
#include <iostream>
using namespace std;

string invertKey(const string& secret_msg, const string &key) {
    string plaintext_msg;
    for (auto ch : secret_msg) {
        if (isalpha(ch)) {
            size_t offset = key.find(ch); // 避免线性搜索的方案是使用一个映射表 
            // 上述查找与外层循环合力，导致该程序变成了O(n^2).
            assert(offset != string::npos);
            plaintext_msg += 'A' + offset;
        } else {
            plaintext_msg += ch;
        }
    }
    return plaintext_msg;
}

int main() {

    cout << "Letter substitution cipher." << endl;
    string key = "QWERTYUIOPASDFGHJKLZXCVBNM";
    string msg = "VGKATKL GY ZIT VGKSR XFOZT!";
    // cout << "Enter a 26-letter key: ";
    // getline(cin, ct);
    // assert(ct.length() == 26);
    
    // cout << "Enter a message: ";
    // getline(cin, msg);
    cout << "Encoded message: " << invertKey(msg, key);
    return 0;
}
```

---

### 优化版本:通过array构建map结构

```cpp
#include <iostream>
#include <string>
#include <cassert>
#include <array>
#include <algorithm> // for std::fill

std::string invertKey(const std::string& secret_msg, const std::string &key) {
    std::string plaintext_msg;
    array<int, 26> offset; // 用于记录密钥中每个字符的位置
	
    std::fill(offset.begin(), offset.end(), -1); // -1 表示当前字符不在密钥中

    // 记录密钥中每个字符的位置
    for (int i = 0; i < key.size(); ++i) {
      //  char ch = std::toupper(key[i]); // 统一转换为大写字母
        offset[ch - 'A'] = i; // 字符对应的位置为索引值
    }

    // 根据密钥中的位置获取明文字符
    for (char ch : secret_msg) {
        if (std::isalpha(ch)) {
            char upperCh = std::toupper(ch);
            int pos = offset[upperCh - 'A'];
            assert(pos != -1); // 检查是否找到了对应的位置
            plaintext_msg += 'A' + pos;
        } else {
            plaintext_msg += ch;
        }
    }

    return plaintext_msg;
}
```

### 使用自带的unordered_map

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <cassert>

std::string invertKey(const std::string& secret_msg, const std::string &key) {
    std::string plaintext_msg;
    std::unordered_map<char, size_t> charMap; // 字符到位置的映射

    // 构建字符到位置的映射
    for (size_t i = 0; i < key.size(); ++i) {
        charMap[key[i]] = i;
    }

    // 根据映射获取明文字符
    for (char ch : secret_msg) {
        if (std::isalpha(ch)) {
            char upperCh = std::toupper(ch);
            auto it = charMap.find(upperCh);
            assert(it != charMap.end()); // 检查是否找到了对应的位置
            plaintext_msg += 'A' + it->second;
        } else {
            plaintext_msg += ch;
        }
    }

    return plaintext_msg;
}
```

