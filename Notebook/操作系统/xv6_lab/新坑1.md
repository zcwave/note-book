记录一下自己的实验过程，也希望自己能跟完整个课程。

课程的网址:https://pdos.csail.mit.edu/6.828/2021/schedule.html

## 环境搭配

以下是我的机器，`ubuntu 20.04 LTS`这个版本做这个实验非常的好用，可以减少许多不必要的烦恼，节约时间。

对于其他系统的安装，也可以参考[课程中的Tool页面的介绍](https://pdos.csail.mit.edu/6.828/2021/tools.html)

```shell
~ > uname -a
Linux 5.4.0-77-generic #Ubuntu 20.04.3 LTS  x86_64  GNU/Linux
```

首先，按照课程的介绍安装必要的依赖。

```shell
~ > sudo apt-get install git build-essential gdb-multiarch gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 
~ > sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6
```

其次，将xv6的源代码下载到本地。**务必要选择一个分支，不然文件夹是空的。**

>   更多的关于git的操作请参考[git用户手册](https://mirrors.edge.kernel.org/pub/software/scm/git/docs/user-manual.html)

```shell
 ~ > git clone git://g.csail.mit.edu/xv6-labs-2021
 ~ > cd xv6-labs-2021
 ~/xv6-labs-2021 > git checkout util
```

在目录`xv6-labs-2021`中，执行`make qemu`,如果一切都正常的话，就会出现如下界面，我们的环境搭建就成功了(maybe)。

```shell
~/xv6-labs-2021 > make qemu
qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0

xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$ 
```

>   xv6 没有`ps`命令，但是，如果您键入Ctrl-p，内核将打印有关每个进程的信息。如果您现在尝试，您将看到两行：一行用于`init`，另一行用于`sh`。
>
>   要退出`qemu`，请键入: Ctrl+a 之后输入x. 更多的知识请参考[第一个实验](https://pdos.csail.mit.edu/6.828/2021/labs/util.html)

如果无法成功的编译xv6的源码，就要依次检查apt安装的工具是否正常被安装。

## 使用`gdb-multiarch`进行调试

在用户目录下编辑`.gdbinit`

```shell
~ > vim .gdbinit
```

在.`.gdbinit`中添加`add-auto-load-safe-path ~/xv6-labs-2021/.gdbinit` 其中`~/xv6-labs-2021/`应当是下载xv6的源代码的路径。                                                 

之后在一个窗口运行`make qemu-gdb` 在另一个窗口运行(要切换到`xv6-labs-2021`的目录内)`gdb-multiarch`即可。

![image-20211108212047110](%E6%96%B0%E5%9D%911.assets/image-20211108212047110.png)

然后加载一下符号表就可以调试特定文件了例如`(gdb) file user/_ls`

![image-20211108213259607](%E6%96%B0%E5%9D%911.assets/image-20211108213259607.png)

## 关于GDB

也许这两篇文章有所帮助？

http://beej.us/guide/bggdb/

与

```gdb
Summary of GDB commands for x86-64 Systems

  Command                  Effect

Starting:
  gdb
  gdb <file>

Running and stopping

  quit                      Exit gdb
  run                       Run program
  run 1 2 3                 Run program with command-line arguments 1 2 3
  kill			    Stop the program
  quit			    Exit gdb
  Ctrl-d		    Exit gdb
  	Note: Ctrl-C does not exit from gdb, but halts the current
  	gdb command


Breakpoints

  break sum                 Set breakpoint at the entry to function sum
  break *0x80483c3          Set breakpoint at address 0x80483c3
  delete 1                  Delete breakpoint 1
  disable 1		    Disable the breakpoint 1
			       (gdb numbers each breakpoint you create)
  enable 1		    Enable breakpoint 1
  delete                    Delete all breakpoints
  clear sum		    Clear any breakpoints at the entry to function sum

Execution

  stepi                     Execute one instruction
  stepi 4                   Execute four instructions
  nexti                     Like stepi, but proceed
			    through function calls without stopping
  step                      Execute one C statement
  continue                  Resume execution until the next breakpoint
  until 3                   Continue executing until program hits breakpoint 3
  finish                    Resume execution until current function returns
  call sum(1, 2)            Call sum(1,2) and print return value

Examining code

  disas                     Disassemble current function
  disas sum                 Disassemble function sum
  disas 0x80483b7           Disassemble function around 0x80483b7
  disas 0x80483b7 0x80483c7 Disassemble code within specified address range

  print /x $rip             Print program counter in hex
  print /d $rip             Print program counter in decimal
  print /t $rip             Print program counter in binary

Examining data

  print /d $rax             Print contents of %rax in decimal
  print /x $rax             Print contents of %rax in hex
  print /t $rax             Print contents of %rax in binary
  print /d (int)$rax        Print contents of %rax in decimal after
			    sign-extending lower 32-bits.

                            You need this to print 32-bit, negative
                            numbers stored in the lower 32 bits of
                            %rax. For example, if the lower 32-bits of
                            %rax store 0xffffffff, you will see 

			    (gdb) print $rax
			    $1 = 4294967295
			    (gdb) print (int)$rax
			    $2 = -1
			    (gdb)

			    
  print 0x100               Print decimal representation of 0x100
  print /x 555              Print hex representation of 555
  print /x ($rsp+8)         Print (contents of %rsp) + 8 in hex
  print *(int *) 0xbffff890 Print integer at address 0xbffff890
  print *(int *) ($rsp+8)   Print integer at address %rsp + 8
  print (char *) 0xbfff890  Examine a string stored at 0xbffff890

  x/w   0xbffff890          Examine (4-byte) word starting at address
			    0xbffff890
  x/w   $rsp                Examine (4-byte) word starting at address in $rsp
  x/wd  $rsp                Examine (4-byte) word starting at address in $rsp.
			    Print in decimal
  x/2w  $rsp                Examine two (4-byte) words starting at address
			    in $rsp
  x/2wd $rsp                Examine two (4-byte) words starting at address
			    in $rsp. Print in decimal
  x/g   $rsp                Examine (8-byte) word starting at address in $rsp.
  x/gd  $rsp                Examine (8-byte) word starting at address in $rsp.
			    Print in decimal
  x/a   $rsp                Examine address in $rsp. Print as offset from
			    previous global symbol.
  x/s   0xbffff890          Examine a string stored at 0xbffff890
  x/20b sum                 Examine first 20 opcode bytes of function sum
  x/10i sum                 Examine first 10 instructions of function sum

  (Note: the format string for the `x' command has the general form 
     x/[NUM][SIZE][FORMAT] where
 
    NUM  = number of objects to display
    SIZE = size of each object (b=byte, h=half-word, w=word,
	                        g=giant (quad-word))
    FORMAT = how to display each object (d=decimal, x=hex, o=octal, etc.)

    If you don't specify SIZE or FORMAT, either a default value, or the last
    value you specified in a previous `print' or `x' command is used.
  )

Useful information

  backtrace		    Print the current address and stack backtrace
  where			    Print the current address and stack backtrace

  info program		    Print current status of the program)
  info functions	    Print functions in program
  info stack		    Print backtrace of the stack)
  info frame		    Print information about the current stack frame
  info registers	    Print registers and their contents
  info breakpoints	    Print status of user-settable breakpoints

  display /FMT EXPR         Print expression EXPR using format FMT
			    every time GDB stops
  undisplay                 Turn off display mode
  help                      Get information about gdb
```

